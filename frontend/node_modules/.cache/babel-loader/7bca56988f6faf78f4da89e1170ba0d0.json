{"ast":null,"code":"import _classCallCheck from \"C:/Users/giovt/Desktop/crowdpulse old/CrowdPulse/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/giovt/Desktop/crowdpulse old/CrowdPulse/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"C:/Users/giovt/Desktop/crowdpulse old/CrowdPulse/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/giovt/Desktop/crowdpulse old/CrowdPulse/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/giovt/Desktop/crowdpulse old/CrowdPulse/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/giovt/Desktop/crowdpulse old/CrowdPulse/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar _class, _temp;\n\nimport React from 'react';\nimport map from 'lodash.map';\nimport reduce from 'lodash.reduce';\nimport filter from 'lodash.filter';\nimport min from 'lodash.min';\nimport max from 'lodash.max';\nimport isNumber from 'lodash.isnumber';\nimport L from 'leaflet';\nimport { MapLayer, withLeaflet } from 'react-leaflet';\nimport simpleheat from 'simpleheat';\nimport PropTypes from 'prop-types';\n\nfunction isInvalid(num) {\n  return !isNumber(num) && !num;\n}\n\nfunction isValid(num) {\n  return !isInvalid(num);\n}\n\nfunction isValidLatLngArray(arr) {\n  return filter(arr, isValid).length === arr.length;\n}\n\nfunction isInvalidLatLngArray(arr) {\n  return !isValidLatLngArray(arr);\n}\n\nfunction safeRemoveLayer(leafletMap, el) {\n  var _leafletMap$getPanes = leafletMap.getPanes(),\n      overlayPane = _leafletMap$getPanes.overlayPane;\n\n  if (overlayPane && overlayPane.contains(el)) {\n    overlayPane.removeChild(el);\n  }\n}\n\nfunction shouldIgnoreLocation(loc) {\n  return isInvalid(loc.lng) || isInvalid(loc.lat);\n}\n\nexport default withLeaflet((_temp = _class = /*#__PURE__*/function (_MapLayer) {\n  _inherits(HeatmapLayer, _MapLayer);\n\n  var _super = _createSuper(HeatmapLayer);\n\n  function HeatmapLayer() {\n    _classCallCheck(this, HeatmapLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HeatmapLayer, [{\n    key: \"createLeafletElement\",\n    value: function createLeafletElement() {\n      return null;\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this = this;\n\n      var canAnimate = this.props.leaflet.map.options.zoomAnimation && L.Browser.any3d;\n      var zoomClass = \"leaflet-zoom-\".concat(canAnimate ? 'animated' : 'hide');\n      var mapSize = this.props.leaflet.map.getSize();\n      var transformProp = L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);\n      this._el = L.DomUtil.create('canvas', zoomClass);\n      this._el.style[transformProp] = '50% 50%';\n      this._el.width = mapSize.x;\n      this._el.height = mapSize.y;\n      var el = this._el;\n      var Heatmap = L.Layer.extend({\n        onAdd: function onAdd(leafletMap) {\n          return leafletMap.getPanes().overlayPane.appendChild(el);\n        },\n        addTo: function addTo(leafletMap) {\n          leafletMap.addLayer(_this);\n          return _this;\n        },\n        onRemove: function onRemove(leafletMap) {\n          return safeRemoveLayer(leafletMap, el);\n        }\n      });\n      this.leafletElement = new Heatmap();\n\n      _get(_getPrototypeOf(HeatmapLayer.prototype), \"componentDidMount\", this).call(this);\n\n      this._heatmap = simpleheat(this._el);\n      this.reset();\n\n      if (this.props.fitBoundsOnLoad) {\n        this.fitBounds();\n      }\n\n      this.attachEvents();\n      this.updateHeatmapProps(this.getHeatmapProps(this.props));\n    }\n  }, {\n    key: \"getMax\",\n    value: function getMax(props) {\n      return props.max || 3.0;\n    }\n  }, {\n    key: \"getRadius\",\n    value: function getRadius(props) {\n      return props.radius || 30;\n    }\n  }, {\n    key: \"getMaxZoom\",\n    value: function getMaxZoom(props) {\n      return props.maxZoom || 18;\n    }\n  }, {\n    key: \"getMinOpacity\",\n    value: function getMinOpacity(props) {\n      return props.minOpacity || 0.01;\n    }\n  }, {\n    key: \"getBlur\",\n    value: function getBlur(props) {\n      return props.blur || 15;\n    }\n  }, {\n    key: \"getHeatmapProps\",\n    value: function getHeatmapProps(props) {\n      return {\n        minOpacity: this.getMinOpacity(props),\n        maxZoom: this.getMaxZoom(props),\n        radius: this.getRadius(props),\n        blur: this.getBlur(props),\n        max: this.getMax(props),\n        gradient: props.gradient\n      };\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var currentProps = this.props;\n      var nextHeatmapProps = this.getHeatmapProps(nextProps);\n      this.updateHeatmapGradient(nextHeatmapProps.gradient);\n      var hasRadiusUpdated = nextHeatmapProps.radius !== currentProps.radius;\n      var hasBlurUpdated = nextHeatmapProps.blur !== currentProps.blur;\n\n      if (hasRadiusUpdated || hasBlurUpdated) {\n        this.updateHeatmapRadius(nextHeatmapProps.radius, nextHeatmapProps.blur);\n      }\n\n      if (nextHeatmapProps.max !== currentProps.max) {\n        this.updateHeatmapMax(nextHeatmapProps.max);\n      }\n    }\n    /**\r\n     * Update various heatmap properties like radius, gradient, and max\r\n     */\n\n  }, {\n    key: \"updateHeatmapProps\",\n    value: function updateHeatmapProps(props) {\n      this.updateHeatmapRadius(props.radius, props.blur);\n      this.updateHeatmapGradient(props.gradient);\n      this.updateHeatmapMax(props.max);\n    }\n    /**\r\n     * Update the heatmap's radius and blur (blur is optional)\r\n     */\n\n  }, {\n    key: \"updateHeatmapRadius\",\n    value: function updateHeatmapRadius(radius, blur) {\n      if (radius) {\n        this._heatmap.radius(radius, blur);\n      }\n    }\n    /**\r\n     * Update the heatmap's gradient\r\n     */\n\n  }, {\n    key: \"updateHeatmapGradient\",\n    value: function updateHeatmapGradient(gradient) {\n      if (gradient) {\n        this._heatmap.gradient(gradient);\n      }\n    }\n    /**\r\n     * Update the heatmap's maximum\r\n     */\n\n  }, {\n    key: \"updateHeatmapMax\",\n    value: function updateHeatmapMax(maximum) {\n      if (maximum) {\n        this._heatmap.max(maximum);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      safeRemoveLayer(this.props.leaflet.map, this._el);\n    }\n  }, {\n    key: \"fitBounds\",\n    value: function fitBounds() {\n      var points = this.props.points;\n      var lngs = map(points, this.props.longitudeExtractor);\n      var lats = map(points, this.props.latitudeExtractor);\n      var ne = {\n        lng: max(lngs),\n        lat: max(lats)\n      };\n      var sw = {\n        lng: min(lngs),\n        lat: min(lats)\n      };\n\n      if (shouldIgnoreLocation(ne) || shouldIgnoreLocation(sw)) {\n        return;\n      }\n\n      this.props.leaflet.map.fitBounds(L.latLngBounds(L.latLng(sw), L.latLng(ne)));\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.props.leaflet.map.invalidateSize();\n\n      if (this.props.fitBoundsOnUpdate) {\n        this.fitBounds();\n      }\n\n      this.reset();\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate() {\n      return true;\n    }\n  }, {\n    key: \"attachEvents\",\n    value: function attachEvents() {\n      var _this2 = this;\n\n      var leafletMap = this.props.leaflet.map;\n      leafletMap.on('viewreset', function () {\n        return _this2.reset();\n      });\n      leafletMap.on('moveend', function () {\n        return _this2.reset();\n      });\n\n      if (leafletMap.options.zoomAnimation && L.Browser.any3d) {\n        leafletMap.on('zoomanim', this._animateZoom, this);\n      }\n    }\n  }, {\n    key: \"_animateZoom\",\n    value: function _animateZoom(e) {\n      var scale = this.props.leaflet.map.getZoomScale(e.zoom);\n\n      var offset = this.props.leaflet.map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this.props.leaflet.map._getMapPanePos());\n\n      if (L.DomUtil.setTransform) {\n        L.DomUtil.setTransform(this._el, offset, scale);\n      } else {\n        this._el.style[L.DomUtil.TRANSFORM] = \"\".concat(L.DomUtil.getTranslateString(offset), \" scale(\").concat(scale, \")\");\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var topLeft = this.props.leaflet.map.containerPointToLayerPoint([0, 0]);\n      L.DomUtil.setPosition(this._el, topLeft);\n      var size = this.props.leaflet.map.getSize();\n\n      if (this._heatmap._width !== size.x) {\n        this._el.width = this._heatmap._width = size.x;\n      }\n\n      if (this._heatmap._height !== size.y) {\n        this._el.height = this._heatmap._height = size.y;\n      }\n\n      if (this._heatmap && !this._frame && !this.props.leaflet.map._animating) {\n        this._frame = L.Util.requestAnimFrame(this.redraw, this);\n      }\n\n      this.redraw();\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      var r = this._heatmap._r;\n      var size = this.props.leaflet.map.getSize();\n      var maxIntensity = this.props.max === undefined ? 1 : this.getMax(this.props);\n      var maxZoom = this.props.maxZoom === undefined ? this.props.leaflet.map.getMaxZoom() : this.getMaxZoom(this.props);\n      var v = 1 / Math.pow(2, Math.max(0, Math.min(maxZoom - this.props.leaflet.map.getZoom(), 12)) / 2);\n      var cellSize = r / 2;\n\n      var panePos = this.props.leaflet.map._getMapPanePos();\n\n      var offsetX = panePos.x % cellSize;\n      var offsetY = panePos.y % cellSize;\n      var getLat = this.props.latitudeExtractor;\n      var getLng = this.props.longitudeExtractor;\n      var getIntensity = this.props.intensityExtractor;\n\n      var inBounds = function inBounds(p, bounds) {\n        return bounds.contains(p);\n      };\n\n      var filterUndefined = function filterUndefined(row) {\n        return filter(row, function (c) {\n          return c !== undefined;\n        });\n      };\n\n      var roundResults = function roundResults(results) {\n        return reduce(results, function (result, row) {\n          return map(filterUndefined(row), function (cell) {\n            return [Math.round(cell[0]), Math.round(cell[1]), Math.min(cell[2], maxIntensity), cell[3]];\n          }).concat(result);\n        }, []);\n      };\n\n      var accumulateInGrid = function accumulateInGrid(points, leafletMap, bounds) {\n        return reduce(points, function (grid, point) {\n          var latLng = [getLat(point), getLng(point)];\n\n          if (isInvalidLatLngArray(latLng)) {\n            //skip invalid points\n            return grid;\n          }\n\n          var p = leafletMap.latLngToContainerPoint(latLng);\n\n          if (!inBounds(p, bounds)) {\n            return grid;\n          }\n\n          var x = Math.floor((p.x - offsetX) / cellSize) + 2;\n          var y = Math.floor((p.y - offsetY) / cellSize) + 2;\n          grid[y] = grid[y] || [];\n          var cell = grid[y][x];\n          var alt = getIntensity(point);\n          var k = alt * v;\n\n          if (!cell) {\n            grid[y][x] = [p.x, p.y, k, 1];\n          } else {\n            cell[0] = (cell[0] * cell[2] + p.x * k) / (cell[2] + k); // x\n\n            cell[1] = (cell[1] * cell[2] + p.y * k) / (cell[2] + k); // y\n\n            cell[2] += k; // accumulated intensity value\n\n            cell[3] += 1;\n          }\n\n          return grid;\n        }, []);\n      };\n\n      var getBounds = function getBounds() {\n        return new L.Bounds(L.point([-r, -r]), size.add([r, r]));\n      };\n\n      var getDataForHeatmap = function getDataForHeatmap(points, leafletMap) {\n        return roundResults(accumulateInGrid(points, leafletMap, getBounds(leafletMap)));\n      };\n\n      var data = getDataForHeatmap(this.props.points, this.props.leaflet.map);\n\n      this._heatmap.clear();\n\n      this._heatmap.data(data).draw(this.getMinOpacity(this.props));\n\n      this._frame = null;\n\n      if (this.props.onStatsUpdate && this.props.points && this.props.points.length > 0) {\n        this.props.onStatsUpdate(reduce(data, function (stats, point) {\n          stats.max = point[3] > stats.max ? point[3] : stats.max;\n          stats.min = point[3] < stats.min ? point[3] : stats.min;\n          return stats;\n        }, {\n          min: Infinity,\n          max: -Infinity\n        }));\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return HeatmapLayer;\n}(MapLayer), _class.propTypes = {\n  points: PropTypes.array.isRequired,\n  longitudeExtractor: PropTypes.func.isRequired,\n  latitudeExtractor: PropTypes.func.isRequired,\n  intensityExtractor: PropTypes.func.isRequired,\n  fitBoundsOnLoad: PropTypes.bool,\n  fitBoundsOnUpdate: PropTypes.bool,\n  onStatsUpdate: PropTypes.func,\n\n  /* props controlling heatmap generation */\n  max: PropTypes.number,\n  radius: PropTypes.number,\n  maxZoom: PropTypes.number,\n  minOpacity: PropTypes.number,\n  blur: PropTypes.number,\n  gradient: PropTypes.object\n}, _temp));","map":{"version":3,"sources":["C:/Users/giovt/Desktop/crowdpulse old/CrowdPulse/frontend/src/HeatmapLayer.js"],"names":["React","map","reduce","filter","min","max","isNumber","L","MapLayer","withLeaflet","simpleheat","PropTypes","isInvalid","num","isValid","isValidLatLngArray","arr","length","isInvalidLatLngArray","safeRemoveLayer","leafletMap","el","getPanes","overlayPane","contains","removeChild","shouldIgnoreLocation","loc","lng","lat","canAnimate","props","leaflet","options","zoomAnimation","Browser","any3d","zoomClass","mapSize","getSize","transformProp","DomUtil","testProp","_el","create","style","width","x","height","y","Heatmap","Layer","extend","onAdd","appendChild","addTo","addLayer","onRemove","leafletElement","_heatmap","reset","fitBoundsOnLoad","fitBounds","attachEvents","updateHeatmapProps","getHeatmapProps","radius","maxZoom","minOpacity","blur","getMinOpacity","getMaxZoom","getRadius","getBlur","getMax","gradient","nextProps","currentProps","nextHeatmapProps","updateHeatmapGradient","hasRadiusUpdated","hasBlurUpdated","updateHeatmapRadius","updateHeatmapMax","maximum","points","lngs","longitudeExtractor","lats","latitudeExtractor","ne","sw","latLngBounds","latLng","invalidateSize","fitBoundsOnUpdate","on","_animateZoom","e","scale","getZoomScale","zoom","offset","_getCenterOffset","center","_multiplyBy","subtract","_getMapPanePos","setTransform","TRANSFORM","getTranslateString","topLeft","containerPointToLayerPoint","setPosition","size","_width","_height","_frame","_animating","Util","requestAnimFrame","redraw","r","_r","maxIntensity","undefined","v","Math","pow","getZoom","cellSize","panePos","offsetX","offsetY","getLat","getLng","getIntensity","intensityExtractor","inBounds","p","bounds","filterUndefined","row","c","roundResults","results","result","cell","round","concat","accumulateInGrid","grid","point","latLngToContainerPoint","floor","alt","k","getBounds","Bounds","add","getDataForHeatmap","data","clear","draw","onStatsUpdate","stats","Infinity","propTypes","array","isRequired","func","bool","number","object"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport map from 'lodash.map';\r\nimport reduce from 'lodash.reduce';\r\nimport filter from 'lodash.filter';\r\nimport min from 'lodash.min';\r\nimport max from 'lodash.max';\r\nimport isNumber from 'lodash.isnumber';\r\nimport L from 'leaflet';\r\nimport { MapLayer, withLeaflet } from 'react-leaflet';\r\nimport simpleheat from 'simpleheat';\r\nimport PropTypes from 'prop-types';\r\n\r\nexport type LngLat = {\r\n  lng: number;\r\n  lat: number;\r\n}\r\n\r\nexport type Point = {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport type Bounds = {\r\n  contains: (latLng: LngLat) => boolean;\r\n}\r\n\r\nexport type Pane = {\r\n  appendChild: (element: Object) => void;\r\n}\r\n\r\nexport type Panes = {\r\n  overlayPane: Pane;\r\n}\r\n\r\nexport type Map = {\r\n  layerPointToLatLng: (lngLat: Point) => LngLat;\r\n  latLngToLayerPoint: (lngLat: LngLat) => Point;\r\n  on: (event: string, handler: () => void) => void;\r\n  getBounds: () => Bounds;\r\n  getPanes: () => Panes;\r\n  invalidateSize: () => void;\r\n  options: Object;\r\n}\r\n\r\nexport type LeafletZoomEvent = {\r\n  zoom: number;\r\n  center: Object;\r\n}\r\n\r\nfunction isInvalid(num: number): boolean {\r\n  return !isNumber(num) && !num;\r\n}\r\n\r\nfunction isValid(num: number): boolean {\r\n  return !isInvalid(num);\r\n}\r\n\r\nfunction isValidLatLngArray(arr: Array<number>): boolean {\r\n  return filter(arr, isValid).length === arr.length;\r\n}\r\n\r\nfunction isInvalidLatLngArray(arr: Array<number>): boolean {\r\n  return !isValidLatLngArray(arr);\r\n}\r\n\r\nfunction safeRemoveLayer(leafletMap: Map, el): void {\r\n  const { overlayPane } = leafletMap.getPanes();\r\n  if (overlayPane && overlayPane.contains(el)) {\r\n    overlayPane.removeChild(el);\r\n  }\r\n}\r\n\r\nfunction shouldIgnoreLocation(loc: LngLat): boolean {\r\n  return isInvalid(loc.lng) || isInvalid(loc.lat);\r\n}\r\n\r\nexport default withLeaflet(class HeatmapLayer extends MapLayer {\r\n  static propTypes = {\r\n    points: PropTypes.array.isRequired,\r\n    longitudeExtractor: PropTypes.func.isRequired,\r\n    latitudeExtractor: PropTypes.func.isRequired,\r\n    intensityExtractor: PropTypes.func.isRequired,\r\n    fitBoundsOnLoad: PropTypes.bool,\r\n    fitBoundsOnUpdate: PropTypes.bool,\r\n    onStatsUpdate: PropTypes.func,\r\n    /* props controlling heatmap generation */\r\n    max: PropTypes.number,\r\n    radius: PropTypes.number,\r\n    maxZoom: PropTypes.number,\r\n    minOpacity: PropTypes.number,\r\n    blur: PropTypes.number,\r\n    gradient: PropTypes.object\r\n  };\r\n\r\n  createLeafletElement() {\r\n    return null;\r\n  }\r\n\r\n  componentDidMount(): void {\r\n    const canAnimate = this.props.leaflet.map.options.zoomAnimation && L.Browser.any3d;\r\n    const zoomClass = `leaflet-zoom-${canAnimate ? 'animated' : 'hide'}`;\r\n    const mapSize = this.props.leaflet.map.getSize();\r\n    const transformProp = L.DomUtil.testProp(\r\n      ['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']\r\n    );\r\n\r\n    this._el = L.DomUtil.create('canvas', zoomClass);\r\n    this._el.style[transformProp] = '50% 50%';\r\n    this._el.width = mapSize.x;\r\n    this._el.height = mapSize.y;\r\n\r\n    const el = this._el;\r\n\r\n    const Heatmap = L.Layer.extend({\r\n      onAdd: (leafletMap) => leafletMap.getPanes().overlayPane.appendChild(el),\r\n      addTo: (leafletMap) => {\r\n        leafletMap.addLayer(this);\r\n        return this;\r\n      },\r\n      onRemove: (leafletMap) => safeRemoveLayer(leafletMap, el)\r\n    });\r\n\r\n    this.leafletElement = new Heatmap();\r\n    super.componentDidMount();\r\n    this._heatmap = simpleheat(this._el);\r\n    this.reset();\r\n\r\n    if (this.props.fitBoundsOnLoad) {\r\n      this.fitBounds();\r\n    }\r\n    this.attachEvents();\r\n    this.updateHeatmapProps(this.getHeatmapProps(this.props));\r\n  }\r\n\r\n  getMax(props) {\r\n    return props.max || 3.0;\r\n  }\r\n\r\n  getRadius(props) {\r\n    return props.radius || 30;\r\n  }\r\n\r\n  getMaxZoom(props) {\r\n    return props.maxZoom || 18;\r\n  }\r\n\r\n  getMinOpacity(props) {\r\n    return props.minOpacity || 0.01;\r\n  }\r\n\r\n  getBlur(props) {\r\n    return props.blur || 15;\r\n  }\r\n\r\n  getHeatmapProps(props) {\r\n    return {\r\n      minOpacity: this.getMinOpacity(props),\r\n      maxZoom: this.getMaxZoom(props),\r\n      radius: this.getRadius(props),\r\n      blur: this.getBlur(props),\r\n      max: this.getMax(props),\r\n      gradient: props.gradient\r\n    };\r\n  }\r\n\r\n  componentWillReceiveProps(nextProps: Object): void {\r\n    const currentProps = this.props;\r\n    const nextHeatmapProps = this.getHeatmapProps(nextProps);\r\n\r\n    this.updateHeatmapGradient(nextHeatmapProps.gradient);\r\n\r\n    const hasRadiusUpdated = nextHeatmapProps.radius !== currentProps.radius;\r\n    const hasBlurUpdated = nextHeatmapProps.blur !== currentProps.blur;\r\n\r\n    if (hasRadiusUpdated || hasBlurUpdated) {\r\n      this.updateHeatmapRadius(nextHeatmapProps.radius, nextHeatmapProps.blur);\r\n    }\r\n\r\n    if (nextHeatmapProps.max !== currentProps.max) {\r\n      this.updateHeatmapMax(nextHeatmapProps.max);\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Update various heatmap properties like radius, gradient, and max\r\n   */\r\n  updateHeatmapProps(props: Object) {\r\n    this.updateHeatmapRadius(props.radius, props.blur);\r\n    this.updateHeatmapGradient(props.gradient);\r\n    this.updateHeatmapMax(props.max);\r\n  }\r\n\r\n  /**\r\n   * Update the heatmap's radius and blur (blur is optional)\r\n   */\r\n  updateHeatmapRadius(radius: number, blur: ?number): void {\r\n    if (radius) {\r\n      this._heatmap.radius(radius, blur);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the heatmap's gradient\r\n   */\r\n  updateHeatmapGradient(gradient: Object): void {\r\n    if (gradient) {\r\n      this._heatmap.gradient(gradient);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the heatmap's maximum\r\n   */\r\n  updateHeatmapMax(maximum: number): void {\r\n    if (maximum) {\r\n      this._heatmap.max(maximum);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount(): void {\r\n    safeRemoveLayer(this.props.leaflet.map, this._el);\r\n  }\r\n\r\n  fitBounds(): void {\r\n    const points = this.props.points;\r\n    const lngs = map(points, this.props.longitudeExtractor);\r\n    const lats = map(points, this.props.latitudeExtractor);\r\n    const ne = { lng: max(lngs), lat: max(lats) };\r\n    const sw = { lng: min(lngs), lat: min(lats) };\r\n\r\n    if (shouldIgnoreLocation(ne) || shouldIgnoreLocation(sw)) {\r\n      return;\r\n    }\r\n\r\n    this.props.leaflet.map.fitBounds(L.latLngBounds(L.latLng(sw), L.latLng(ne)));\r\n  }\r\n\r\n  componentDidUpdate(): void {\r\n    this.props.leaflet.map.invalidateSize();\r\n    if (this.props.fitBoundsOnUpdate) {\r\n      this.fitBounds();\r\n    }\r\n    this.reset();\r\n  }\r\n\r\n  shouldComponentUpdate(): boolean {\r\n    return true;\r\n  }\r\n\r\n  attachEvents(): void {\r\n    const leafletMap: Map = this.props.leaflet.map;\r\n    leafletMap.on('viewreset', () => this.reset());\r\n    leafletMap.on('moveend', () => this.reset());\r\n    if (leafletMap.options.zoomAnimation && L.Browser.any3d) {\r\n      leafletMap.on('zoomanim', this._animateZoom, this);\r\n    }\r\n  }\r\n\r\n\r\n  _animateZoom(e: LeafletZoomEvent): void {\r\n    const scale = this.props.leaflet.map.getZoomScale(e.zoom);\r\n    const offset = this.props.leaflet.map\r\n                      ._getCenterOffset(e.center)\r\n                      ._multiplyBy(-scale)\r\n                      .subtract(this.props.leaflet.map._getMapPanePos());\r\n\r\n    if (L.DomUtil.setTransform) {\r\n      L.DomUtil.setTransform(this._el, offset, scale);\r\n    } else {\r\n      this._el.style[L.DomUtil.TRANSFORM] =\r\n          `${L.DomUtil.getTranslateString(offset)} scale(${scale})`;\r\n    }\r\n  }\r\n\r\n  reset(): void {\r\n    const topLeft = this.props.leaflet.map.containerPointToLayerPoint([0, 0]);\r\n    L.DomUtil.setPosition(this._el, topLeft);\r\n\r\n    const size = this.props.leaflet.map.getSize();\r\n\r\n    if (this._heatmap._width !== size.x) {\r\n      this._el.width = this._heatmap._width = size.x;\r\n    }\r\n    if (this._heatmap._height !== size.y) {\r\n      this._el.height = this._heatmap._height = size.y;\r\n    }\r\n\r\n    if (this._heatmap && !this._frame && !this.props.leaflet.map._animating) {\r\n      this._frame = L.Util.requestAnimFrame(this.redraw, this);\r\n    }\r\n\r\n    this.redraw();\r\n  }\r\n\r\n  redraw(): void {\r\n    const r = this._heatmap._r;\r\n    const size = this.props.leaflet.map.getSize();\r\n\r\n    const maxIntensity = this.props.max === undefined\r\n                            ? 1\r\n                            : this.getMax(this.props);\r\n\r\n    const maxZoom = this.props.maxZoom === undefined\r\n                        ? this.props.leaflet.map.getMaxZoom()\r\n                        : this.getMaxZoom(this.props);\r\n\r\n    const v = 1 / Math.pow(\r\n      2,\r\n      Math.max(0, Math.min(maxZoom - this.props.leaflet.map.getZoom(), 12)) / 2\r\n    );\r\n\r\n    const cellSize = r / 2;\r\n    const panePos = this.props.leaflet.map._getMapPanePos();\r\n    const offsetX = panePos.x % cellSize;\r\n    const offsetY = panePos.y % cellSize;\r\n    const getLat = this.props.latitudeExtractor;\r\n    const getLng = this.props.longitudeExtractor;\r\n    const getIntensity = this.props.intensityExtractor;\r\n\r\n    const inBounds = (p, bounds) => bounds.contains(p);\r\n\r\n    const filterUndefined = (row) => filter(row, c => c !== undefined);\r\n\r\n    const roundResults = (results) => reduce(results, (result, row) =>\r\n      map(filterUndefined(row), (cell) => [\r\n        Math.round(cell[0]),\r\n        Math.round(cell[1]),\r\n        Math.min(cell[2], maxIntensity),\r\n        cell[3]\r\n      ]).concat(result),\r\n      []\r\n    );\r\n\r\n    const accumulateInGrid = (points, leafletMap, bounds) => reduce(points, (grid, point) => {\r\n      const latLng = [getLat(point), getLng(point)];\r\n      if (isInvalidLatLngArray(latLng)) { //skip invalid points\r\n        return grid;\r\n      }\r\n\r\n      const p = leafletMap.latLngToContainerPoint(latLng);\r\n\r\n      if (!inBounds(p, bounds)) {\r\n        return grid;\r\n      }\r\n\r\n      const x = Math.floor((p.x - offsetX) / cellSize) + 2;\r\n      const y = Math.floor((p.y - offsetY) / cellSize) + 2;\r\n\r\n      grid[y] = grid[y] || [];\r\n      const cell = grid[y][x];\r\n\r\n      const alt = getIntensity(point);\r\n      const k = alt * v;\r\n\r\n      if (!cell) {\r\n        grid[y][x] = [p.x, p.y, k, 1];\r\n      } else {\r\n        cell[0] = (cell[0] * cell[2] + p.x * k) / (cell[2] + k); // x\r\n        cell[1] = (cell[1] * cell[2] + p.y * k) / (cell[2] + k); // y\r\n        cell[2] += k; // accumulated intensity value\r\n        cell[3] += 1;\r\n      }\r\n\r\n      return grid;\r\n    }, []);\r\n\r\n    const getBounds = () => new L.Bounds(L.point([-r, -r]), size.add([r, r]));\r\n\r\n    const getDataForHeatmap = (points, leafletMap) => roundResults(\r\n        accumulateInGrid(\r\n          points,\r\n          leafletMap,\r\n          getBounds(leafletMap)\r\n        )\r\n      );\r\n\r\n    const data = getDataForHeatmap(this.props.points, this.props.leaflet.map);\r\n\r\n    this._heatmap.clear();\r\n    this._heatmap.data(data).draw(this.getMinOpacity(this.props));\r\n\r\n    this._frame = null;\r\n\r\n    if (this.props.onStatsUpdate && this.props.points && this.props.points.length > 0) {\r\n      this.props.onStatsUpdate(\r\n        reduce(data, (stats, point) => {\r\n          stats.max = point[3] > stats.max ? point[3] : stats.max;\r\n          stats.min = point[3] < stats.min ? point[3] : stats.min;\r\n          return stats;\r\n        }, { min: Infinity, max: -Infinity })\r\n      );\r\n    }\r\n  }\r\n\r\n\r\n  render(): React.Element {\r\n    return null;\r\n  }\r\n\r\n});\r\n"]},"metadata":{},"sourceType":"module"}